name: 'ðŸš€ semver create release'
description: 'Get the commits from the last commit'
inputs:
  configuration:
    description: 'path to the configuration.yml which store the scopes and commit types'
    required: false
    default: ''
  create-gh-release:
    description: |
      flag for creating a GH release for the whole repository. 
      tag-version must be true.
      Make sure the workflow has permissions for creating a GH release
      or provide a GH token with permissions for doing it.
    required: true
    default: 'false'
  github-token:
    description: 'GitHub token for creating GH release'
    required: false
  include-previous-non-releasable-commits:
    description: 'flag for including non-release commits in the changelog. Those are commits with release type "none"'
    required: false
    default: 'false'
  print-annotations:
    description: 'flag for printing release details as annotations in the GH workflow'
    required: false
    default: 'false'
  print-summary:
    description: 'flag for printing whole repository release details'
    required: true
    default: 'false'
  tag-version:
    description: 'flag for tagging the repo version in the release commit'
    required: false
    default: 'true'
  tag-prefix:
    description: |
      string to be added as prefix to the tag. 
      Only available if tag-version is true.
      Example: v -> tag: v1.0.0
    required: false
    default: ''
  gh-user-name:
    description: 'GH user name for the semver commit'
    required: false
    default: 'github-actions-semver[bot]'
  gh-user-email:
    description: 'GH user email for the semver commit'
    required: false
    default: 'github-actions-semver[bot]@users.noreply.github.com'

outputs:
  new-version-released:
    value: ${{ steps.semver.outputs.release-required }}
    description: 'flag for creating GH release'
  version:
    value: ${{ steps.semver.outputs.version }}
    description: 'repository version'
  release-title:
    value: ${{ steps.parse-changes.outputs.release-title }}
    description: 'release title extracted from the squashed commit title'
  release-type:
    value: ${{ steps.semver.outputs.release-type }}
    description: 'release type as major, minor or patch'
  release-url:
    value: ${{ steps.create-repo-release.outputs.gh-release-url }}
    description: 'GH release url. Only available if create-gh-release is true'
  commit-id:
    value: ${{ steps.commit.outputs.last_commit_id }}
    description: 'Commit ID that includes the version.json and changelog updated'
  changes:
    value: ${{ steps.parse-changes.outputs.changes }}
    description: 'changes parsed: [{type,releaseAssociated,scopes,description,originalCommit}]'
  changelog-record:
    value: ${{ steps.semver.outputs.changelog-record }}
    description: |
      changelog-record JSON object with title, body and content
      title   -> '# {version} {release title}'
      body    -> 'changes entries listed in grouped and listed by release type in markdown format'
      content -> title + body
  scopes:
    value: ${{ steps.semver.outputs.scopes }}
    description: 'Only available if scopes configuration provided. Format: {scopename:{version,changes,changelog-record}}'

runs:
  using: "composite"
  steps:
    - name: Validate Context and squashed commit received
      uses: actions/github-script@v7
      with:
        script: |
          if (context.eventName !== 'push') {
              throw new Error(`This GH action only supports push events.`)
          }
          const commits = context.payload.commits
          if (commits.length > 1) {
              throw new Error(`This GH action only expects one commit.`)
          }

    - name: Install dependencies
      shell: bash
      working-directory: ${{ github.action_path }}
      run: |
        npm install --omit=dev

    - name: Process configuration
      uses: actions/github-script@v7
      id: config
      env:
        INPUT_CONFIG: ${{ inputs.configuration }}
        NODE_MODULES_PATH: ${{ github.action_path }}/node_modules
        SCHEMA: ${{ github.action_path }}/config.schema.yml
      with:
        script: |
          const yml = require(`${process.env.NODE_MODULES_PATH}/js-yaml`)
          const Ajv = require(`${process.env.NODE_MODULES_PATH}/ajv`)
          const fs  = require('fs')

          const schemaPath    = process.env.SCHEMA
          const inputConfig   = process.env.INPUT_CONFIG
          const schemaContent = fs.readFileSync(schemaPath)
          const schema        = yml.load(schemaContent)
          let   config        = {}

          if(inputConfig !== '') {
            const configPath    = inputConfig
            const configContent = fs.readFileSync(configPath)
            config              = yml.load(configContent)
          }

          const ajv       = new Ajv({ useDefaults: true })  // add default values to the config properties
          const validate  = ajv.compile(schema)
          const valid     = validate(config)

          if (!valid) {
            const errorsJson = JSON.stringify(validate.errors, null, 2)
            core.setFailed(`configuration file is not valid: ${errorsJson}`)
          }

          core.startGroup('Configuration')
          console.log('config:', JSON.stringify(config, null, 2))
          core.endGroup()

          core.setOutput('config', config)

    - name: Getting changes from previous Commits
      uses: actions/github-script@v7
      if: ${{ inputs.include-previous-non-releasable-commits == 'true' }}
      id: get-previous-changes
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        NODE_MODULES_PATH: ${{ github.action_path }}/node_modules
      with:
        script: |
          core.startGroup('Getting changes from previous commits')

          const { parseChange }     = require('${{ github.action_path }}/functions/parse-change')
          const { parseLastCommit } = require('${{ github.action_path }}/functions/parse-last-commit')

          const conf                = JSON.parse(process.env.CONFIG)

          const { data: versionJSONCommits } = await github.rest.repos.listCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            path: 'version.json'
          })

          if(versionJSONCommits.length === 0) {
            core.notice('version.json file not found. Getting Previous changes is not supported in this case', {title: 'cangulo-actions/semver notice'})
            return
          }

          const lastReleaseCommitSHA  = versionJSONCommits[0].sha
          const currentCommitSHA      = context.payload.commits[0].id

          const { data: comparison } = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            base: lastReleaseCommitSHA,
            head: currentCommitSHA
          })

          const previousChanges = []
          comparison.commits
            .filter(x => x.sha !== currentCommitSHA)    // ignore the current commit because it will be parsed later
            .map(x => x.commit.message)
            .forEach(commitMsg => {
              const { entries } = parseLastCommit(commitMsg)
              const changes = entries
                .map(x => parseChange(x, conf.commits))
              previousChanges.push(...changes)
            })
          
          console.log('previousChanges:', JSON.stringify(previousChanges, null, 2))
          core.endGroup()
          core.setOutput('previous-changes', previousChanges)

    - name: Parsing Changes from current commit
      uses: actions/github-script@v7
      id: parse-changes
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        NODE_MODULES_PATH: ${{ github.action_path }}/node_modules
        PREVIOUS_CHANGES: ${{ steps.get-previous-changes.outputs.previous-changes || '[]' }}
      with:
        script: |
          core.startGroup('Parsing changes from last commit')

          const { parseChange }     = require('${{ github.action_path }}/functions/parse-change')
          const { parseLastCommit } = require('${{ github.action_path }}/functions/parse-last-commit')

          const conf            = JSON.parse(process.env.CONFIG)
          const commitMsg       = context.payload.commits[0].message
          const previousChanges = JSON.parse(process.env.PREVIOUS_CHANGES)

          const { title, entries } = parseLastCommit(commitMsg)
          console.log(`title: ${title}`)
          console.log('entries:', JSON.stringify(entries, null, 2))


          const changes = entries
            .map(x => parseChange(x, conf.commits))
            .concat(previousChanges)
          console.log('changes:', JSON.stringify(changes, null, 2))
          core.endGroup()
          
          core.setOutput('changes',       changes)
          core.setOutput('release-title', title)

    - name: Semver
      uses: actions/github-script@v7
      id: semver
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        NODE_MODULES_PATH: ${{ github.action_path }}/node_modules
        CHANGELOG_RECORD_TITLE_TEMPLATE: ${{ github.action_path }}/templates/changelog-record-title.md
        CHANGELOG_RECORD_BODY_TEMPLATE: ${{ github.action_path }}/templates/changelog-record-body.md
        CHANGES: ${{ steps.parse-changes.outputs.changes }}
        RELEASE_TITLE: ${{ steps.parse-changes.outputs.release-title }}
      with:
        script: |
          const { Index }     = require('${{ github.action_path }}/index.js')

          const conf                  = JSON.parse(process.env.CONFIG)
          const changes               = JSON.parse(process.env.CHANGES)
          const title                 = process.env.RELEASE_TITLE
          const changelogTemplates    = {
            title: process.env.CHANGELOG_RECORD_TITLE_TEMPLATE,
            body: process.env.CHANGELOG_RECORD_BODY_TEMPLATE
          }

          const releaseDetails = Index(changes, title, conf, changelogTemplates)

          if(releaseDetails.releaseRequired){
            core.startGroup(`Next version is ${releaseDetails.version}. Details (click here):`)
            console.log(JSON.stringify(releaseDetails, null, 2))
            core.endGroup()
          }else{
            core.startGroup(`Commit merged did not trigger a new release. Commit details (click here):`)
            const commitMerged = context.payload.commits[0]
            console.log(JSON.stringify(commitMerged, null, 2))
            core.endGroup()
          }

          core.setOutput('version',           releaseDetails.version)
          core.setOutput('release-type',      releaseDetails.releaseType)
          core.setOutput('release-required',  releaseDetails.releaseRequired)
          core.setOutput('changelog-record',  releaseDetails.changelogRecord)
          core.setOutput('scopes',            releaseDetails.scopes)

    - name: Build release commit
      if: ${{ steps.semver.outputs.release-required == 'true' }}
      id: build-commit-and-tags
      uses: actions/github-script@v7
      env:
        TAG_REPO_VERSION: ${{ inputs.tag-version }}
        TAG_PREFIX: ${{ inputs.tag-prefix }}
        CONFIG: ${{ steps.config.outputs.config }}
        RELEASE_TITLE: ${{ steps.parse-changes.outputs.release-title }}
        CHANGELOG_RECORD_BODY: ${{ fromJSON(steps.semver.outputs.changelog-record).body }}
        REPO_TAG_VERSION: ${{ steps.semver.outputs.version }}
        SCOPES: ${{ steps.semver.outputs.scopes }}
      with:
        script: |
          const tagRepoVersion          = process.env.TAG_REPO_VERSION === 'true'
          const conf                    = JSON.parse(process.env.CONFIG)
          const supportedScopesConfig   = conf.scopes.list
          const releaseTitle            = process.env.RELEASE_TITLE
          const changelogRecordBody     = process.env.CHANGELOG_RECORD_BODY
          const repoTagVersion          = process.env.REPO_TAG_VERSION
          const repoTagPrefix           = process.env.TAG_PREFIX
          const scopes                  = JSON.parse(process.env.SCOPES)
          const tags                    = []

          const releaseCommit = {
            title: `[skip ci] created release ${repoTagVersion} - ${releaseTitle}`,
            body: changelogRecordBody
          }

          if(tagRepoVersion) {
            const repoVersionTag = {
              name: `${repoTagPrefix}${repoTagVersion}`,
              title: releaseTitle,
              body: changelogRecordBody
            }
            tags.push(repoVersionTag)
          }

          const tagsPerScope = {}
          for (const [scope, properties] of Object.entries(scopes)) {
            const scopeConfig   = supportedScopesConfig.find(x => x.key === scope)
            const tagVersion    = scopeConfig.versioning['tag-version'] ?? conf.scopes['tag-version']
            const tagPrefix     = scopeConfig.versioning['tag-prefix']  ?? conf.scopes['tag-prefix']
            if(tagVersion){
              const tagName       = `${scope}-${tagPrefix}${properties.version}`
              tagsPerScope[scope] =  tagName
              const scopeTag     = {
                name: tagName,
                title: releaseTitle,
                body: properties.changelogRecord.body
              }
              tags.push(scopeTag)
            }
          }

          core.setOutput('release-commit',  releaseCommit)
          core.setOutput('tags',            tags)
          core.setOutput('tags-per-scope',  tagsPerScope)

    - name: Commit changes
      if: ${{ steps.semver.outputs.release-required == 'true' }}
      id: commit
      shell: bash
      env:
        COMMIT: ${{ steps.build-commit-and-tags.outputs.release-commit }}
        TAGS: ${{ steps.build-commit-and-tags.outputs.tags }}
      run: |
        # committing the changes in semver files
        git config user.name  "${{ inputs.gh-user-name }}"
        git config user.email "${{ inputs.gh-user-email }}"
        
        commit_title=$(echo $COMMIT | jq -r '.title')
        commit_body=$(echo $COMMIT  | jq -r '.body')

        git add . 
        git commit -m "$commit_title" -m "$commit_body"
        
        echo $TAGS | jq -c '.[]' | while read -r tag; do
          _tag=$(echo $tag | jq -r '.name')
          _tag_title=$(echo $tag | jq -r '.title')
          _tag_body=$(echo $tag | jq -r '.body')
          git tag -a "$_tag" -m "$_tag_title" -m "$_tag_body"
        done
        
        git push --follow-tags

        last_commit_id=$(git rev-parse HEAD)

        echo "last_commit_id=$last_commit_id"
        echo "last_commit_id=$last_commit_id" >> $GITHUB_OUTPUT

    - name: Create GH Release for the whole repository
      if: ${{ inputs.create-gh-release == 'true' &&  steps.semver.outputs.release-required == 'true' }}
      uses: actions/github-script@v7
      id: create-repo-release
      env:
        CHANGELOG_RECORD_BODY: ${{ fromJSON(steps.semver.outputs.changelog-record).body }}
      with:
        github-token: ${{ inputs.github-token || github.token }}
        script: |
          const response = await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `${{ steps.semver.outputs.version}}`,
            target_commitish: '${{ steps.commit.outputs.last_commit_id }}',
            name: `${{ steps.semver.outputs.version}} ${{ steps.parse-changes.outputs.release-title}}`,
            body: process.env.CHANGELOG_RECORD_BODY,
          })

          const releaseUrl = response.data.html_url
          core.setOutput('gh-release-url', releaseUrl)

    - name: printing summary for Repo Release
      if: ${{ inputs.print-summary == 'true' }}
      uses: actions/github-script@v7
      env:
        NEW_VERSION_RELEASED: ${{ steps.semver.outputs.release-required }}
        RELEASE_VERSION: ${{ steps.semver.outputs.version }}
        RELEASE_TITLE: ${{ steps.parse-changes.outputs.release-title }}
        RELEASE_TYPE: ${{ steps.semver.outputs.release-type }}
        RELEASE_COMMIT_ID: ${{ steps.commit.outputs.last_commit_id }}
        GH_RELEASE_CREATED: ${{ inputs.create-gh-release }}
        GH_RELEASE_URL: ${{ steps.create-repo-release.outputs.gh-release-url }}

      with:
        script: |
          const newVersionRelease = process.env.NEW_VERSION_RELEASED === 'true'

          if(newVersionRelease) {
            const releaseVersion    = process.env.RELEASE_VERSION
            const releaseTitle      = process.env.RELEASE_TITLE
            const releaseType       = process.env.RELEASE_TYPE  
            const releaseCommitId   = process.env.RELEASE_COMMIT_ID
            const ghReleaseCreated  = process.env.GH_RELEASE_CREATED === 'true'
            const linkToCommit      = `https://github.com/${context.repo.owner}/${context.repo.repo}/commit/${releaseCommitId}`

            const tableHeader = [{data: 'version', header: true}, {data: 'title', header: true}, {data: 'type', header: true}]
            const tableRow    = [releaseVersion, releaseTitle, releaseType]

            if(ghReleaseCreated) {
              tableHeader.push({data: 'GH Release', header: true})
              const ghReleaseUrl        = `<a href="${process.env.GH_RELEASE_URL}">link</a>`
              tableRow.push(ghReleaseUrl)
            }

            const table = [tableHeader, tableRow]

            core.summary
              .addHeading('ðŸš€ New release')
              .addTable(table)
              .addHeading('commit id:', 3)
              .addLink(releaseCommitId, linkToCommit)
              .write()
          }else{
            core.summary
              .addRaw('changes did not triggered a new release')
              .write()
          }

    - name: Create GH releases for scopes
      if: ${{ steps.semver.outputs.scopes != '{}' }}
      uses: actions/github-script@v7
      id: create-scopes-releases
      env:
        CONFIG: ${{ steps.config.outputs.config }}
        SCOPES: ${{ steps.semver.outputs.scopes }}
        SCOPE_TAGS: ${{ steps.build-commit-and-tags.outputs.tags-per-scope }}
      with:
        github-token: ${{ inputs.github-token || github.token }}
        script: |
          const conf                        = JSON.parse(process.env.CONFIG)
          const scopes                      = JSON.parse(process.env.SCOPES)
          const scopeTags                   = JSON.parse(process.env.SCOPE_TAGS)
          const supportedScopesConfig       = conf.scopes.list
          const ghReleasesUrls              = {}

          for (const [scope, properties] of Object.entries(scopes)) {
            const scopeConfig   = supportedScopesConfig.find(x => x.key === scope)
            const createRelease = scopeConfig.versioning['create-gh-release'] ?? conf.scopes['create-gh-release']
            const tagCreated    = scopeTags[scope] !== undefined
            if(createRelease && tagCreated) {
              const response = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: scopeTags[scope],
                target_commitish: '${{ steps.commit.outputs.last_commit_id }}',
                name: `${scopeTags[scope]} ${{ steps.parse-changes.outputs.release-title }}`,
                body: properties.changelogRecord.body,
              })
              ghReleasesUrls[scope] = response.data.html_url
            }
          }
          
          if(ghReleasesUrls.length > 0) {
            core.startGroup('GH Releases per scope')
            console.log(JSON.stringify(ghReleasesUrls, null, 2))
            core.endGroup()
          }
          
          core.setOutput('gh-releases-urls', ghReleasesUrls)

    - name: printing summary for Scopes Releases
      if: ${{ steps.semver.outputs.scopes != '{}' && fromJSON(steps.config.outputs.config).scopes['print-summary'] }}
      uses: actions/github-script@v7
      env:
        SCOPES: ${{ steps.semver.outputs.scopes }}
        GH_RELEASES_URLS: ${{ steps.create-scopes-releases.outputs.gh-releases-urls }}
        SCOPE_TAGS: ${{ steps.build-commit-and-tags.outputs.tags-per-scope }}
      with:
        script: |
          const scopes            = JSON.parse(process.env.SCOPES)
          const scopeTags         = JSON.parse(process.env.SCOPE_TAGS)
          const ghReleasesUrls    = JSON.parse(process.env.GH_RELEASES_URLS)
          const ghReleasesCreated = Object.keys(ghReleasesUrls).length > 0

          const tableHeaders = [
            {data: 'scope',   header: true}, 
            {data: 'version', header: true}, 
            {data: 'tag',     header: true}, 
            {data: 'type',    header: true}
          ]
          if(ghReleasesCreated) { 
            tableHeaders.push({data: 'GH Release', header: true})
          }
          const tableRows    = []
          
          Object
            .entries(scopes)
            .forEach(([scope, properties]) => {
              const releaseVersion  = properties.version
              const tag             = scopeTags[scope] ?? 'tag not created'
              const releaseType     = properties.releaseType  
              const row             = [scope, releaseVersion, tag, releaseType]
              if(ghReleasesCreated) {
                const ghReleaseLink   = ghReleasesUrls[scope] ? `<a href="${ghReleasesUrls[scope]}">link</a>` : 'not created'
                row.push(ghReleaseLink)
              }
              tableRows.push(row)
          })

          const table = [tableHeaders, ...tableRows]

          core.summary
            .addHeading('ðŸš€ Releases per scope')
            .addTable(table)
            .write()

    - name: Write Check Annotations
      uses: actions/github-script@v7
      if: ${{ inputs.print-annotations == 'true' }}
      env:
        NEW_VERSION_RELEASED: ${{ steps.semver.outputs.release-required }}
        RELEASE_VERSION: ${{ steps.semver.outputs.version }}
        RELEASE_TITLE: ${{ steps.parse-changes.outputs.release-title }}
      with:
        script: |
          const newVersionRelease = process.env.NEW_VERSION_RELEASED === 'true'

          if(newVersionRelease) {
            const releaseVersion    = process.env.RELEASE_VERSION
            const releaseTitle      = process.env.RELEASE_TITLE

            core.notice(`Version ${releaseVersion} released!`, {title: 'cangulo-actions/semver result'})
          }else{
            core.notice('Changes did not triggered a new release', {title: 'cangulo-actions/semver result'})
          }

# refresh_GH_action_version 20240127-1
